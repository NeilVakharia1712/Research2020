A common problem for compilers and text editors is determining whether the
parentheses in a string are balanced and properly nested. For example, the string
((())())() contains properly nested pairs of parentheses, which the strings )()( and
()) do not. Give an algorithm that returns true if a string contains properly nested
and balanced parentheses, and false if otherwise. For full credit, identify the position
of the first offending parenthesis if the string is not properly nested and balanced.

Write a program to reverse the direction of a given singly-linked list. In other
words, after the reversal all pointers should now point backwards. Your algorithm
should take linear time.

We have seen how dynamic arrays enable arrays to grow while still achieving
constant-time amortized performance. This problem concerns extending dynamic
arrays to let them both grow and shrink on demand.

Consider an underflow strategy that cuts the array size in half whenever the
array falls below half full. Give an example sequence of insertions and deletions
where this strategy gives a bad amortized cost.

Then, give a better underflow strategy than that suggested above, one that
achieves constant amortized cost per deletion.

Design a dictionary data structure in which search, insertion, and deletion can
all be processed in O(1) time in the worst case. You may assume the set elements
are integers drawn from a finite set 1, 2, .., n, and initialization can take O(n) time.

Find the overhead fraction (the ratio of data space over total space) for each
of the following binary tree implementations on n nodes:
(a) All nodes store data, two child pointers, and a parent pointer. The data field
requires four bytes and each pointer requires four bytes.
(b) Only leaf nodes store data; internal nodes store two child pointers. The data
field requires four bytes and each pointer requires two bytes.

Describe how to modify any balanced tree data structure such that search,
insert, delete, minimum, and maximum still take O(log n) time each, but successor
and predecessor now take O(1) time each. Which operations have to be modified
to support this?

Suppose you have access to a balanced dictionary data structure, which supports
each of the operations search, insert, delete, minimum, maximum, successor, and
predecessor in O(log n) time. Explain how to modify the insert and delete operations
so they still take O(log n) but now minimum and maximum take O(1) time. (Hint:
think in terms of using the abstract dictionary operations, instead of mucking about
with pointers and the like.)

Design a data structure to support the following operations: insert(x,T) – Insert item x into the set T. delete(k,T) – Delete the kth smallest element from T. member(x,T) – Return true iff x ∈ T. All operations must take O(log n) time on an n-element set.

A concatenate operation takes two sets S1 and S2, where every key in S1
is smaller than any key in S2, and merges them together. Give an algorithm to
concatenate two binary search trees into one binary search tree. The worst-case
running time should be O(h), where h is the maximal height of the two trees.

In the bin-packing problem, we are given n metal objects, each weighing between
zero and one kilogram. Our goal is to find the smallest number of bins that will
hold the n objects, with each bin holding one kilogram at most.

The best-fit heuristic for bin packing is as follows. Consider the objects in the
order in which they are given. For each object, place it into the partially filled
bin with the smallest amount of extra room after the object is inserted.. If
no such bin exists, start a new bin. Design an algorithm that implements the
best-fit heuristic (taking as input the n weights w1, w2, ...,wn and outputting
the number of bins used) in O(n log n) time.

Repeat the above using the worst-fit heuristic, where we put the next object in
the partially filled bin with the largest amount of extra room after the object
is inserted.

Design a data structure that uses O(n2) space and answers queries in O(1)
time.

Design a data structure that uses O(n) space and answers queries in O(log n)
time. For partial credit, your data structure can use O(n log n) space and have
O(log n) query time.

Suppose you are given an input set S of n numbers, and a black box that if
given any sequence of real numbers and an integer k instantly and correctly answers
whether there is a subset of input sequence whose sum is exactly k. Show how to
use the black box O(n) times to find a subset of S that adds up to k.

[8] Extend the data structure of the previous problem to support insertions and
deletions. Each element now has both a key and a value. An element is accessed
by its key. The addition operation is applied to the values, but the elements are
accessed by its key. The Partial sum operation is different. Add(k,y) – Add the value y to the item with key k. Insert(k,y) – Insert a new item with key k and value y. Delete(k) – Delete the item with key k.

8] Design a data structure that allows one to search, insert, and delete an integer
X in O(1) time (i.e. , constant time, independent of the total number of integers
stored). Assume that 1 ≤ X ≤ n and that there are m+n units of space available,
where m is the maximum number of integers that can be in the table at any one
time. (Hint: use two arrays A[1..n] and B[1..m].) You are not allowed to initialize
either A or B, as that would take O(m) or O(n) operations. This means the arrays
are full of random garbage to begin with, so you must be very careful

Implement versions of several different dictionary data structures, such as linked
lists, binary trees, balanced binary search trees, and hash tables. Conduct experiments
to assess the relative performance of these data structures in a simple application
that reads a large text file and reports exactly one instance of each word
that appears within it. This application can be efficiently implemented by maintaining
a dictionary of all distinct words that have appeared thus far in the text
and inserting/reporting each word that is not found. Write a brief report with your
conclusions.

A Caesar shift (see Section 18.6 (page 641)) is a very simple class of ciphers for
secret messages. Unfortunately, they can be broken using statistical properties of
English. Develop a program capable of decrypting Caesar shifts of sufficiently long
texts.

What method would you use to look up a word in a dictionary?

Imagine you have a closet full of shirts. What can you do to organize your shirts
for easy retrieval?

Write a function to find the middle node of a singly-linked list.

Write a function to compare whether two binary trees are identical. Identical
trees have the same key value at each position and the same structure.

Write a program to convert a binary search tree into a linked list.

Implement an algorithm to reverse a linked list. Now do it without recursion.

What is the best data structure for maintaining URLs that have been visited by
a Web crawler? Give an algorithm to test whether a given URL has already been
visited, optimizing both space and time.

You are given a search string and a magazine. You seek to generate all the characters
in search string by cutting them out from the magazine. Give an algorithm
to efficiently determine whether the magazine contains all the letters in the search
string.

Reverse the words in a sentence—i.e., “My name is Chris” becomes “Chris is
name My.” Optimize for time and space.

Determine whether a linked list contains a loop as quickly as possible without
using any extra storage. Also, identify the location of the loop.

You have an unordered array X of n integers. Find the array M containing
n elements where Mi is the product of all integers in X except for Xi. You may
not use division. You can use extra memory. (Hint: There are solutions faster than
O(n2).)

Give an algorithm for finding an ordered word pair (e.g., “New York”) occurring
with the greatest frequency in a given webpage. Which data structures would you
use? Optimize both time and space.