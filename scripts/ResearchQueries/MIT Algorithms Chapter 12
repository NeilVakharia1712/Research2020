What is the difference between the binary-search-tree property and the min-heap
property (see page 153)? Can the min-heap property be used to print out the keys
of an n-node tree in sorted order in O(N) time? Show how, or explain why not.

Give a nonrecursive algorithm that performs an inorder tree walk.

Give recursive algorithms that perform preorder and postorder tree walks in O(n)
time on a tree of n nodes.

Argue that since sorting n elements takes O(nlgn) time in the worst case in
the comparison model, any comparison-based algorithm for constructing a binary
search tree from an arbitrary list of n elements takes O(nlgn) time in the worst
case.

Suppose that we have numbers between 1 and 1000 in a binary search tree, and we
want to search for the number 363. Which of the following sequences could not be
the sequence of nodes examined?

Write recursive versions of TREE-MINIMUM and TREE-MAXIMUM

Write the TREE-PREDECESSOR procedure.

Show that if a node in a binary search tree has two children, then its successor has
no left child and its predecessor has no right child.

Consider a binary search tree T whose keys are distinct. Show that if the right
subtree of a node x in T is empty and x has a successor y, then y is the lowest
ancestor of x whose left child is also an ancestor of x. (Recall that every node is
its own ancestor.)

An alternative method of performing an inorder tree walk of an n-node binary
search tree finds the minimum element in the tree by calling TREE-MINIMUM and
then making n-1 calls to TREE-SUCCESSOR. Prove that this algorithm runs
in O(n) time

Prove that no matter what node we start at in a height-h binary search tree, k
successive calls to TREE-SUCCESSOR take O(k+h) time.

Let T be a binary search tree whose keys are distinct, let x be a leaf node, and let y
be its parent. Show that y:key is either the smallest key in T larger than x.key or
the largest key in T smaller than x.key.

Give a recursive version of the TREE-INSERT procedure.

Suppose that we construct a binary search tree by repeatedly inserting distinct values
into the tree. Argue that the number of nodes examined in searching for a
value in the tree is one plus the number of nodes examined when the value was
first inserted into the tree.

We can sort a given set of n numbers by first building a binary search tree containing
these numbers (using TREE-INSERT repeatedly to insert the numbers one by
one) and then printing the numbers by an inorder tree walk. What are the worstcase
and best-case running times for this sorting algorithm?

Is the operation of deletion “commutative” in the sense that deleting x and then y
from a binary search tree leaves the same tree as deleting y and then x? Argue why
it is or give a counterexample.

Suppose that instead of each node x keeping the attribute x:p, pointing to x’s
parent, it keeps x:succ, pointing to x’s successor. Give pseudocode for SEARCH,
INSERT, and DELETE on a binary search tree T using this representation. These
procedures should operate in time O(h), where h is the height of the tree T .

When node ´ in TREE-DELETE has two children, we could choose node y as
its predecessor rather than its successor. What other changes to TREE-DELETE
would be necessary if we did so? Some have argued that a fair strategy, giving
equal priority to predecessor and successor, yields better empirical performance.
How might TREE-DELETE be changed to implement such a fair strategy?

What is the asymptotic performance of TREE-INSERT when used to insert n
items with identical keys into an initially empty binary search tree?